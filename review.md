## 다시 풀 문제
* 섹션1 문제8
* 섹션2 문제5
* 섹션2 문제7
* 섹션3 문제2
* 섹션3 문제4
* 섹션4 문제2 
* 섹션4 문제3
* 섹션4 문제4
* 섹션4 문제5
* 섹션5 문제2
* 섹션5 문제3
* 섹션5 문제5
* 섹션5 문제8
* 섹션6 문제1
* 섹션6 문제3
* 섹션6 문제4
* 섹션6 문제5
* 섹션7 문제3
* 섹션7 문제4
* 섹션7 문제6

## 고찰
* 이중 반복문을 사용할 생각을 안하는 것 같다.
* 확산 연산자도 익숙치 않다. 고려하자.
* 등수 구하기는 쉽지만 모르고 있었다. 계속 확인하자.
* 정규식 사용도 고려하자.
* 유니크한 값들을 다루는 것도 고려하자.
* Map을 사용하는 것도 고려하자.
* Stack을 사용하는 것도 고려하자.
* Selection Sort의 구현을 알아두자.
* Bubble Sort의 구현을 알아두자.
* Insertion Sort의 구현을 알아두자.

## 새로 알게 된 지식
* 영소문자 a 표현: String.fromCharCode(97).
* 영대문자 A 표현: String.fromCharCode(65).
* 기본 최소 숫자 설정 값: Number.MIN_SAFE_INTEGER.
* 배열 생성: Array.from({length: LENGTH}, (_, i)=> i) or Array.of({length: LENGTH}, (_, i)=> i));
* 숫자의 각 자리수로 이루어진 배열: number.toString().split('').
* 배열의 두 요소를 서로 바꾸는 식: [arr[i], arr[j]] = [arr[j], arr[i]].
* 소수 판별 함수: 제곱근 이용.
* 유니크한 값들을 다루는 경우의 데이터타입: SET.
* 괄호에 대한 문제: 대부분 Stack 사용.
* 한 배열의 순환 탐색 문제: Queue 사용.
* 최대/최소값 구하기 문제: Math.max(...arr), Math.min(...arr).
* 배열의 잘못된 순서 요소를 찾는 문제: 정렬한 배열과 졍렬 안 된 배열 비교. 
* 소문자 알파벳이 아닌 것만 판별하는 정규식: /[^a-z]/g.
* 숫자가 아닌 것만 판별하는 정규식: /[^0-9]/g.
* Two Pointer Algorithm: 배열에서 두 개의 포인터를 사용한 알고리즘. 완전탐색보다 시간복잡도가 줄어든다.
* Sliding Window: 배열의 일정 범위 값 비교 목적의, 인덱스를 이동하면서 일정 범위의 윈도우로 들어간 값과 함께 범위 밖으로 밀려난 값을 처리하는 알고리즘.
* Selection Sort: 처음 인덱스부터 시작해서, 그 다음 인덱스부터 차례대로 처음 인덱스에 적합한 값을 찾아서 결정하고, 
                  그 이후에 다음 인덱스부터 같은 동작을 반복하는 정렬 방법. 
* Bubble Sort: 처음 인덱스와 두 번째 인덱스, 두 번째 인덱스와 세 번째, ... n-1과 n번째 인덱스를 비교하고 적합한 값을 찾아 결정하는 동작을, 
               배열의 길이-1번만큼 반복하는 정렬 방법.
* Insertion Sort: 두 번째 인덱스부터 시작해서, 해당 값을 저장해두고, 그 앞의 인덱스부터 첫 번째 인덱스까지 해당 값과 비교하면서, 
                  적합하면 그 인덱스의 값을 그 뒤의 인덱스로 미루는 동작을 하고, 해당 값의 위치를 찾는다면, 
                  그 다음인 세 번째 인덱스, ... 마지막 인덱스까지 같은 동작을 반복하는 정렬 방법. 