## 다시 풀 문제
* 섹션1 문제8
* 섹션2 문제5
* 섹션2 문제7
* 섹션3 문제2
* 섹션3 문제4
* 섹션4 문제2 
* 섹션4 문제3
* 섹션4 문제4
* 섹션4 문제5
* 섹션5 문제2
* 섹션5 문제3
* 섹션5 문제5
* 섹션5 문제8

## 고찰
* 이중 반복문을 사용할 생각을 안하는 것 같다.
* 확산 연산자도 익숙치 않다. 고려하자.
* 등수 구하기는 쉽지만 모르고 있었다. 계속 확인하자.
* 정규식 사용도 고려하자.
* 유니크한 값들을 다루는 것도 고려하자.
* Map을 사용하는 것도 고려하자.

## 새로 알게 된 지식
* Math.max(...arr), Math.min(...arr): 최대, 최소값 구할 경우 사용.
* Number.MIN_SAFE_INTEGER: 기본값으로 최소 숫자 설정이 필요할 경우 사용.
* Array.from({length: LENGTH}, (_, i)=> i): [0,1,2,3,4,...]와 같은 배열 생성이 가능.
* /[^a-z]/g: 소문자 알파벳이 아닌 것만 판별하는 정규식.
* /[^0-9]/g: 숫자가 아닌 것만 판별하는 정규식.
* number.toString().split(''): 숫자의 각 자리수로 이루어진 배열.
* 소수 판별은 제곱근 이용.
* 유니크한 값들을 다룰 경우 SET 데이터 타입 사용.
* Two Pointer Algorithm: 배열에서 두 개의 포인터를 사용한 알고리즘. 완전탐색보다 시간복잡도가 줄어든다.
* Sliding Window: 배열의 일정 범위 값 비교 목적의, 인덱스를 이동하면서 일정 범위의 윈도우로 들어간 값과 함께 범위 밖으로 밀려난 값을 처리하는 알고리즘.