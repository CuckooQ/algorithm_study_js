## 다시 풀 문제

- 섹션1
-       문제8
- 섹션2
-       문제5
-       문제7
- 섹션3
-       문제2
-       문제4
- 섹션4
-       문제2
-       문제3
-       문제4
-       문제5
- 섹션5
-       문제2
-       문제3
-       문제5
-       문제8
- 섹션6
-       문제1
-       문제3
-       문제4
-       문제5
- 섹션7
-       문제3
-       문제4
-       문제6
-       문제8
-       문제9
-       문제10
-       문제11
-       문제12
- 섹션8
-       문제1
-       문제2
-       문제3
-       문제4
-       문제5
-       문제6
-       문제8
-       문제12
-       문제13
-       문제14
- 섹션9
-       문제1
-       문제2
-       문제4
-       문제5
-       문제6
-       문제7
- 섹션10
-       문제1
-       문제3
-       문제4
-       문제5
- 섹션11 (Programmers)
-       문제1
-       문제2
-       문제5
-       문제7
-       문제8
-       문제12
-       문제14
-       문제16
-       문제17
-       문제18
-       문제23
-       문제25
-       문제27
-       문제28
-       문제29
-       문제34
-       문제37
-       문제40
-       문제41
-       문제45
-       문제48
-       문제49
-       문제52
-       문제54
-       문제55
-       문제57
-       문제58
-       문제61
-       문제63
-       문제64
-       문제67
-       문제69
-       문제73
-       문제74
-       문제75
-       문제76
-       문제78
-       문제79
-       문제80
-       문제81
-       문제84
-       문제91
-       문제95
-       문제99
-       문제104
-       문제111
-       문제112
-       문제113
-       문제114
-       문제117
-       문제122
-       문제123
-       문제126
-       문제127
-       문제128
-       문제131
- 섹션12 (LeetCode)
-       문제5
-       문제6
-       문제8
-       문제15
-       문제17

## 못 푼 문제

- 섹션11
-       문제64
-       문제79
-       문제81
-       문제91
-       문제95
-       문제99
-       문제117
-       문제123

## 새로 알게 된 지식

- 영소문자 a 표현: String.fromCharCode(97).
- 영대문자 A 표현: String.fromCharCode(65).
- 배열의 두 요소를 서로 바꾸는 식: [arr[i], arr[j]] = [arr[j], arr[i]].
- 2차원 배열 복사: arr.map((row) => [...row]).
- Math.max(), Math.min()함수의 최대 변수 수가 한정되어 있다.
- Recursive Function: 내부에서 자기 자신을 다시 호출하는 함수.
- Recursive Function의 필수 조건: 종료 조건.
- Tail Recursive Function: 재귀 호출이 끝난 후에 현재 함수에서 추가 연산을 요구하지 않도록 구현하는 재귀함수.
- Memoization: 동일 계산 반복의 경우, 이전 계산 값을 메모리에 저장해서 사용하는 기술.
- Graph: 정점(Vertex)과 간선(Edge)으로 이루어진 자료구조.
- Directed Graph: 정점과 방향이 있는 간선으로 이루어진 자료구조.
- Weighted Graph: 정점과 방향 & 가중치가 있는 간선으로 이루어진 자료구조.
- Adjacency Matrix: 1번 인덱스부터 사용하는 2차원 배열[fromVertex][tovertex]과 가중치값을 사용해서 그래프를 구현하는 방법.
  두 번째 인덱스의 길이는 정점의 개수에 비례해서 늘어난다.
- Adjacency List: 1번 인덱스부터 사용하는 2차원 배열[fromVertex][idx]과 [toVertex, 가중치] 값을 사용해서 그래프를 구현하는 방법.
  두 번째 인덱스의 길이는 fromVertex와 연결된 정점의 개수이다.
- Linked List: 연속된 요소들이 포인터로 연결된 배열.
  각 요소들은 해당 요소의 값과 이전 요소와 다음 요소를 나타내는 속성을 가진다.
  연속된 자료의 다수의 추가/삭제 처리가 있는 경우 사용한다.
- Knapsack Problem: 배낭 문제.
  배낭에 담을 수 있는 무게의 최대값이 정해져 있고, 일정한 가치와 무게가 정해져 있는 배낭에 담을 때,
  가치의 합이 최대가 되도록 짐을 고르는 방법을 찾는 문제.
- Knapsack Problem 종류: Fraction Knapsack + 0-1 Knapsack.
- Fraction Knapsack: 물건을 쪼갤 수 있는 배낭 문제. 그리디 알고리즘으로 해결 가능.
- 0-1 Knapsack: 물건을 쪼갤 수 없는 배낭 문제. Dynamic Programming으로 해결 가능.
- 가우스의 법칙: 합 = (마지막 숫자 + 처음 숫자) \* (전체 개수 / 2)
- 나머지 분배 법칙: 매우 큰 결과값으로 인한 오버플로 방지 목적의 연산 과정에서 소수로 나눈 나머지 값을 사용하는 법칙.
- 다익스트라의 최단 경로 알고리즘: 네트워크에서 하나의 시작 정점으로부터 모든 다른 정점까지의 최단 경로 찾기 알고리즘.
- 다익스트라의 최단 경로 알고리즘 시간 복잡도: O(n^2).
- 플로이드 와샬 최단 경로 알고리즘: 네트워크에서 모든 정점으로부터 모든 다른 정점까지의 최단 경로 찾기 알고리즘.
- 플로이드 와샬 최단 경로 알고리즘 시간 복잡도: O(n^3).
- 두 직선의 교점 공식: Ax + By + E = 0과 Cx + Dy + F = 0일 경우,  
  x = (B*F - E*D) / (A*D - B*C)
  y = (E*C - A*F) / (A*D - B*C)
- 에라토스테네스의 체 알고리즘: 배수인 수들을 제거해서 소수를 구하는 알고리즘.
- 에라토스테네스의 체 알고리즘 시간 복잡도: O(n^1/2).
- 유클리드 호제법: 최대 공약수, 최소 공배수를 구하는 방법.
